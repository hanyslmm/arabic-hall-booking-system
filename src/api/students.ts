import { supabase } from "@/integrations/supabase/client";

export interface Student {
  id: string;
  serial_number: string;
  name: string;
  mobile_phone: string;
  parent_phone?: string;
  city?: string;
  created_at: string;
  updated_at: string;
  created_by?: string;
}

export interface StudentRegistration {
  id: string;
  student_id: string;
  booking_id: string;
  registration_date: string;
  payment_status: 'pending' | 'partial' | 'paid';
  total_fees: number;
  paid_amount: number;
  notes?: string;
  created_at: string;
  updated_at: string;
  created_by?: string;
  student?: Student;
  booking?: {
    id: string;
    hall_id: string;
    teacher_id: string;
    academic_stage_id: string;
    start_time: string;
    days_of_week: string[];
    number_of_students: number;
    halls?: { name: string };
    teachers?: { name: string };
    academic_stages?: { name: string };
  };
}

export interface AttendanceRecord {
  id: string;
  student_registration_id: string;
  attendance_date: string;
  status: 'present' | 'absent' | 'late' | 'excused';
  notes?: string;
  created_at: string;
  created_by?: string;
}

export interface PaymentRecord {
  id: string;
  student_registration_id: string;
  amount: number;
  payment_date: string;
  payment_method: 'cash' | 'card' | 'transfer' | 'other';
  reference_number?: string;
  notes?: string;
  created_at: string;
  created_by?: string;
}

// Students API
export const studentsApi = {
  async getAll(): Promise<Student[]> {
    const { data, error } = await supabase
      .from("students")
      .select("*")
      .order("created_at", { ascending: false });
    
    if (error) throw error;
    return data as Student[];
  },

  async create(studentData: {
    name: string;
    mobile_phone: string;
    parent_phone?: string;
    city?: string;
  }): Promise<Student> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const { data, error } = await supabase
      .from("students")
      .insert([{ ...studentData, created_by: user.user.id, serial_number: '' }])
      .select()
      .single();
    
    if (error) throw error;
    return data as Student;
  },

  async update(id: string, updates: Partial<{
    name: string;
    mobile_phone: string;
    parent_phone: string;
    city: string;
  }>): Promise<Student> {
    const { data, error } = await supabase
      .from("students")
      .update(updates)
      .eq("id", id)
      .select()
      .single();
    
    if (error) throw error;
    return data as Student;
  },

  async delete(id: string): Promise<string> {
    const { error } = await supabase.from("students").delete().eq("id", id);
    if (error) throw error;
    return id;
  },

  async search(searchTerm: string): Promise<Student[]> {
    const { data, error } = await supabase
      .rpc('search_student', { search_term: searchTerm });
    
    if (error) throw error;
    return data as Student[];
  },

  async bulkCreate(students: {
    name: string;
    mobile_phone: string;
    parent_phone?: string;
    city?: string;
  }[]): Promise<Student[]> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const studentsWithUser = students.map(student => ({
      ...student,
      created_by: user.user.id,
      serial_number: '', // Will be auto-generated by trigger
    }));
    
    const { data, error } = await supabase
      .from("students")
      .insert(studentsWithUser)
      .select();
    
    if (error) throw error;
    return data as Student[];
  }
};

// Student Registrations API
export const studentRegistrationsApi = {
  async getAll(): Promise<StudentRegistration[]> {
    const { data, error } = await supabase
      .from("student_registrations")
      .select(`
        *,
        student:students(*),
        booking:bookings(
          *,
          halls(name),
          teachers(name),
          academic_stages(name)
        )
      `)
      .order("created_at", { ascending: false });
    
    if (error) throw error;
    return data as StudentRegistration[];
  },

  async getByBooking(bookingId: string): Promise<StudentRegistration[]> {
    const { data, error } = await supabase
      .from("student_registrations")
      .select(`
        *,
        student:students(*)
      `)
      .eq("booking_id", bookingId)
      .order("created_at", { ascending: false });
    
    if (error) throw error;
    return data as StudentRegistration[];
  },

  async create(registrationData: {
    student_id: string;
    booking_id: string;
    total_fees?: number;
    notes?: string;
  }): Promise<StudentRegistration> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const { data, error } = await supabase
      .from("student_registrations")
      .insert([{ ...registrationData, created_by: user.user.id }])
      .select(`
        *,
        student:students(*),
        booking:bookings(
          *,
          halls(name),
          teachers(name),
          academic_stages(name)
        )
      `)
      .single();
    
    if (error) throw error;
    return data as StudentRegistration;
  },

  async update(id: string, updates: Partial<{
    total_fees: number;
    notes: string;
  }>): Promise<StudentRegistration> {
    const { data, error } = await supabase
      .from("student_registrations")
      .update(updates)
      .eq("id", id)
      .select(`
        *,
        student:students(*),
        booking:bookings(
          *,
          halls(name),
          teachers(name),
          academic_stages(name)
        )
      `)
      .single();
    
    if (error) throw error;
    return data as StudentRegistration;
  },

  async delete(id: string): Promise<string> {
    const { error } = await supabase.from("student_registrations").delete().eq("id", id);
    if (error) throw error;
    return id;
  }
};

// Attendance API
export const attendanceApi = {
  async getByRegistration(registrationId: string): Promise<AttendanceRecord[]> {
    const { data, error } = await supabase
      .from("attendance_records")
      .select("*")
      .eq("student_registration_id", registrationId)
      .order("attendance_date", { ascending: false });
    
    if (error) throw error;
    return data as AttendanceRecord[];
  },

  async create(attendanceData: {
    student_registration_id: string;
    attendance_date: string;
    status: 'present' | 'absent' | 'late' | 'excused';
    notes?: string;
  }): Promise<AttendanceRecord> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const { data, error } = await supabase
      .from("attendance_records")
      .insert([{ ...attendanceData, created_by: user.user.id }])
      .select()
      .single();
    
    if (error) throw error;
    return data as AttendanceRecord;
  },

  async update(id: string, updates: Partial<{
    status: 'present' | 'absent' | 'late' | 'excused';
    notes: string;
  }>): Promise<AttendanceRecord> {
    const { data, error } = await supabase
      .from("attendance_records")
      .update(updates)
      .eq("id", id)
      .select()
      .single();
    
    if (error) throw error;
    return data as AttendanceRecord;
  },

  async bulkCreate(attendanceRecords: {
    student_registration_id: string;
    attendance_date: string;
    status: 'present' | 'absent' | 'late' | 'excused';
    notes?: string;
  }[]): Promise<AttendanceRecord[]> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const recordsWithUser = attendanceRecords.map(record => ({
      ...record,
      created_by: user.user.id,
    }));
    
    const { data, error } = await supabase
      .from("attendance_records")
      .insert(recordsWithUser)
      .select();
    
    if (error) throw error;
    return data as AttendanceRecord[];
  }
};

// Payments API
export const paymentsApi = {
  async getByRegistration(registrationId: string): Promise<PaymentRecord[]> {
    const { data, error } = await supabase
      .from("payment_records")
      .select("*")
      .eq("student_registration_id", registrationId)
      .order("payment_date", { ascending: false });
    
    if (error) throw error;
    return data as PaymentRecord[];
  },

  async create(paymentData: {
    student_registration_id: string;
    amount: number;
    payment_date?: string;
    payment_method?: 'cash' | 'card' | 'transfer' | 'other';
    reference_number?: string;
    notes?: string;
  }): Promise<PaymentRecord> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const { data, error } = await supabase
      .from("payment_records")
      .insert([{ ...paymentData, created_by: user.user.id }])
      .select()
      .single();
    
    if (error) throw error;
    return data as PaymentRecord;
  },

  async update(id: string, updates: Partial<{
    amount: number;
    payment_date: string;
    payment_method: 'cash' | 'card' | 'transfer' | 'other';
    reference_number: string;
    notes: string;
  }>): Promise<PaymentRecord> {
    const { data, error } = await supabase
      .from("payment_records")
      .update(updates)
      .eq("id", id)
      .select()
      .single();
    
    if (error) throw error;
    return data as PaymentRecord;
  },

  async delete(id: string): Promise<string> {
    const { error } = await supabase.from("payment_records").delete().eq("id", id);
    if (error) throw error;
    return id;
  },

  async bulkCreate(paymentRecords: {
    student_registration_id: string;
    amount: number;
    payment_date?: string;
    payment_method?: 'cash' | 'card' | 'transfer' | 'other';
    reference_number?: string;
    notes?: string;
  }[]): Promise<PaymentRecord[]> {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) throw new Error("غير مصرح");
    
    const recordsWithUser = paymentRecords.map(record => ({
      ...record,
      created_by: user.user.id,
      payment_method: record.payment_method || 'cash' as const,
    }));
    
    const { data, error } = await supabase
      .from("payment_records")
      .insert(recordsWithUser)
      .select();
    
    if (error) throw error;
    return data as PaymentRecord[];
  }
};